.TH MOUSE 3
.SH NAME
initmouse, readmouse, closemouse, moveto, cursorswitch, getrect, drawgetrect, menuhit, setcursor \- mouse control
.SH SYNOPSIS
.nf
.B
#include <u.h>
.B
#include <libc.h>
.B
#include <draw.h>
.B
#include <thread.h>
.B
#include <mouse.h>
.B
#include <cursor.h>
.PP
.B
Mousectl	*initmouse(char *file, Image *i)
.PP
.B
int		readmouse(Mousectl *mc)
.PP
.B
int		atomouse();
.PP
.B
void		closemouse(Mousectl *mc)
.PP
.B
void		moveto(Mousectl *mc, Point pt)
.PP
.B
void		setcursor(Mousectl *mc, Cursor *c)
.PP
.B
Rectangle	getrect(int but, Mousectl *mc)
.PP
.B
void		drawgetrect(Rectangle r, int up)
.PP
.B
int		menuhit(int but, Mousectl *mc, Menu *menu, Screen *scr)
.fi
.SH DESCRIPTION
These functions access and control a mouse in a multi-threaded environment.
They use the message-passing
.B Channel
interface in the threads library
(see
.MR thread (3) );
programs that wish a more event-driven, single-threaded approach should use
.MR event (3) .
.PP
The state of the mouse is recorded in a structure,
.BR Mouse ,
defined in
.BR <mouse.h> :
.IP
.EX
.ta 4n +\w'Point 'u +\w'buttons;  'u
typedef struct Mouse Mouse;
struct Mouse
{
	int	buttons;	/* bit array (see bit assignment below) */
	int	scroll;	/* signed scroll distance in pixels or lines */
	Point	xy;
	ulong	msec;
};
.EE
.PP
The
.B Point
.B xy
records the position of the cursor,
.B buttons
the state of the buttons as a bit array,
.B scroll
the signed scroll distance for scrolling events (zero for the rest),
and
.BR msec ,
a millisecond time stamp.
The possible bits that may be set in
.B buttons
are as follows:
.IP
.EX
.ta 4n +\w'Mscrollinertiastart 'u +\w'= 1<<0,  'u
enum
{
	Mbutton1	= 1<<0,	/* left button */
	Mbutton2	= 1<<1,	/* middle button */
	Mbutton3	= 1<<2,	/* right button */
	Mlinescroll	= 1<<3,	/* coarse scroll in line increments */
	Mpixelscroll	= 1<<4,	/* precise scroll in pixel increments */
	Mscrollmotionstart	= 1<<5,	/* upcoming Mpixelscrolls come from one gesture */
	Mscrollmotionstop	= 1<<6,	/* further Mpixelscrolls are standalone again */
	Mscrollinertiastart	= 1<<7,	/* like a regular motion, but for inertial scrolling */
	Mscrollinertiastop	= 1<<8,	/* likewise, back to standalone scrolls */

	Mbuttonsmask	= Mbutton1 | Mbutton2 | Mbutton3,
	Mscrollsmask	= Mlinescroll | Mpixelscroll |
		  Mscrollmotionstart | Mscrollmotionstop |
		  Mscrollinertiastart | Mscrollinertiastop
};
.EE
.PP
The three least significant bits
.BR Mbutton1 ,
.BR Mbutton2 ,
.B Mbutton3
(0 through 2) represent the state of the left, middle, and right mouse
buttons: if a bit is set, the corresponding button is pressed;
if unset, it is released.
The following four bits (3 through 6) represent different mutually
exclusive scrolling events and are never set simultaneously.
Bits
.B Mlinescroll
and
.B Mpixelscroll
(3 and 4) signify a scroll event with, respectively,
a line- and pixel-granular
.B
scroll
distance.
Bits
.B Mscrollmotionstart
and
.B Mscrollmotionstop
(5 and 6) signify the events of a scroll motion being started and
stopped, respectively.
.PP
A scroll motion corresponds to a gesture on a high-precision input
device that spawns multiple coalesced pixel-level scroll events as
part of one whole continuous scrolling action.
The designation of a motion is useful when scrolling can take visible
effect only in discrete chunks (e.g., full lines or rows) rather than
precise pixel offsets.
In such a case, pixel-granular scroll distances received between
a pair of the start and stop events can be successively accumulated,
triggering an interface update once the height of the next chunk to be
brought up on the screen is reached or exceeded, with the remainder of
the accrued distance to be retained in anticipation of the next scroll
event within the motion.
If the scroll state of the program naturally allows for updates on
a per-pixel basis, the start and stop events can be freely ignored,
and every scroll event may be handled independently.
Scroll motions comprise pixel-granular scrolls only; line-granular
scrolls are always standalone.
At most one scroll motion can be in effect at any moment; they do not
overlap in time.
.PP
The routine
.B initmouse
returns a structure through which one may access the mouse:
.IP
.EX
.ta 4n +\w'Channel 'u +\w'*resizec;  'u
typedef struct Mousectl Mousectl;
struct Mousectl
{
	Mouse	m;
	Channel	*c;		/* chan(Mouse)[16] */
	Channel	*resizec;	/* chan(int)[2] */

	char	*file;
	int	mfd;		/* to mouse file */
	int	cfd;		/* to cursor file */
	int	pid;		/* of slave proc */
	Image*	image;		/* of associated window/display */
};
.EE
.PP
The arguments to
.I initmouse
are a
.I file
naming the device file connected to the mouse and an
.I Image
(see
.MR draw (3) )
on which the mouse will be visible.
Typically the file is
nil,
which requests the default
.BR /dev/mouse ;
and the image is the window in which the program is running, held in the variable
.B screen
after a call to
.IR initdraw .
.PP
Once the
.B Mousectl
is set up,
mouse motion will be reported by messages of type
.B Mouse
sent on the
.B Channel
.BR Mousectl.c .
Typically, a message will be sent every time a read of
.B /dev/mouse
succeeds, which is every time the state of the mouse changes.
.PP
When the window is resized, a message is sent on
.BR Mousectl.resizec .
The actual value sent may be discarded; the receipt of the message
tells the program that it should call
.B getwindow
(see
.MR graphics (3) )
to reconnect to the window.
.PP
.I Readmouse
updates the
.B Mouse
structure
.B m
held in the
.BR Mousectl ,
blocking if the state has not changed since the last
.I readmouse
or message sent on the channel.
It calls
.B flushimage
(see
.MR graphics (3) )
before blocking, so any buffered graphics requests are displayed.
.PP
.I Closemouse
closes the file descriptors associated with the mouse, kills the slave processes,
and frees the
.B Mousectl
structure.
.PP
.I Moveto
moves the mouse cursor on the display to the position specified by
.IR pt .
.PP
.I Setcursor
sets the image of the cursor to that specified by
.IR c .
If
.I c
is nil, the cursor is set to the default.
The format of the cursor data is spelled out in
.B <cursor.h>
and described in
.MR graphics (3) .
.PP
.I Getrect
returns the dimensions of a rectangle swept by the user, using the mouse,
in the manner
.MR rio (1)
or
.MR sam (1)
uses to create a new window.
The
.I but
argument specifies which button the user must press to sweep the window;
any other button press cancels the action.
The returned rectangle is all zeros if the user cancels.
.PP
.I Getrect
uses successive calls to
.I drawgetrect
to maintain the red rectangle showing the sweep-in-progress.
The rectangle to be drawn is specified by
.I rc
and the
.I up
parameter says whether to draw (1) or erase (0) the rectangle.
.PP
.I Menuhit
provides a simple menu mechanism.
It uses a
.B Menu
structure defined in
.BR <mouse.h> :
.IP
.EX
.ta 4n +\w'char 'u
typedef struct Menu Menu;
struct Menu
{
	char	**item;
	char	*(*gen)(int);
	int	lasthit;
};
.EE
.PP
.IR Menuhit
behaves the same as its namesake
.I emenuhit
described in
.MR event (3) ,
with two exceptions.
First, it uses a
.B Mousectl
to access the mouse rather than using the event interface;
and second,
it creates the menu as a true window on the
.B Screen
.I scr
(see
.MR window (3) ),
permitting the menu to be displayed in parallel with other activities on the display.
If
.I scr
is null,
.I menuhit
behaves like
.IR emenuhit ,
creating backing store for the menu, writing the menu directly on the display, and
restoring the display when the menu is removed.
.PP
.SH SOURCE
.B \*9/src/libdraw
.SH SEE ALSO
.MR graphics (3) ,
.MR draw (3) ,
.MR event (3) ,
.MR keyboard (3) ,
.MR thread (3) .
